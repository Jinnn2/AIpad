--- a/src/LineArtBoard.tsx
+++ b/src/LineArtBoard.tsx
@@
-import React, { useCallback, useRef, useState } from 'react'
+import React, { useCallback, useMemo, useRef, useState } from 'react'
 import { Stage, Layer, Group, Line as KLine, Rect as KRect, Ellipse as KEllipse, Text as KText } from 'react-konva'
@@
 export type ColorName = 'black'|'blue'|'green'|'grey'|'light-blue'|'light-green'|'light-red'|'light-violet'|'orange'|'red'|'violet'|'white'|'yellow'
@@
 export function planDrafts(norm: ReturnType<typeof normalizeAIStrokePayload>): ShapeDraft[] {
   const drafts: ShapeDraft[] = []
   for (const s of norm.strokes) {
@@
   return drafts
 }
 
 // -----------------------------
-// 3) Konva board implementation
+// 3) Konva board implementation + Drawing Tool (AI v1.1-compatible)
 // -----------------------------
 
 // Brush size mapping to strokeWidth (you may tune these)
 const SIZE_TO_WIDTH = { s: 2, m: 4, l: 6, xl: 10 }
@@
 const colorToStroke = (c: ColorName) => {
   switch (c) {
@@
   }
 }
 
+// ---------- Drawing tool helpers (无依赖“贝塞尔风格平滑”：Chaikin + 均匀采样) ----------
+// 将原始鼠标轨迹点（绝对像素坐标）进行一次或多次 Chaikin corner cutting，使折线更平滑
+function chaikin(points: Array<[number, number]>, iterations = 2): Array<[number, number]> {
+  if (points.length <= 2) return points
+  let pts = points
+  for (let it = 0; it < iterations; it++) {
+    const next: Array<[number, number]> = []
+    for (let i = 0; i < pts.length - 1; i++) {
+      const [x0, y0] = pts[i]
+      const [x1, y1] = pts[i + 1]
+      // 以 0.25 / 0.75 的比例生成新点（近似二次贝塞尔中间控制效果）
+      next.push([0.75 * x0 + 0.25 * x1, 0.75 * y0 + 0.25 * y1])
+      next.push([0.25 * x0 + 0.75 * x1, 0.25 * y0 + 0.75 * y1])
+    }
+    pts = [pts[0], ...next, pts[pts.length - 1]]
+  }
+  return pts
+}
+
+// 按固定步长对平滑后的折线进行路径长度均匀采样，得到等间距点列
+function resampleEvenly(points: Array<[number, number]>, step = 3): Array<[number, number]> {
+  if (points.length <= 2) return points
+  // 预计算每段长度与总长
+  const segs: number[] = []
+  let total = 0
+  for (let i = 0; i < points.length - 1; i++) {
+    const dx = points[i + 1][0] - points[i][0]
+    const dy = points[i + 1][1] - points[i][1]
+    const d = Math.hypot(dx, dy)
+    segs.push(d); total += d
+  }
+  if (total === 0) return [points[0], points[points.length - 1]]
+  const out: Array<[number, number]> = [points[0]]
+  let dist = step
+  let acc = 0
+  let i = 0
+  while (dist < total && i < segs.length) {
+    const segLen = segs[i]
+    if (acc + segLen >= dist) {
+      const t = (dist - acc) / segLen
+      const x = points[i][0] + t * (points[i + 1][0] - points[i][0])
+      const y = points[i][1] + t * (points[i + 1][1] - points[i][1])
+      out.push([x, y])
+      dist += step
+    } else {
+      acc += segLen
+      i++
+    }
+  }
+  out.push(points[points.length - 1])
+  return out
+}
+
+// 将绝对坐标点列转换为 AI 协议笔画（带样式），并给出对应的 ShapeDraft
+function buildAIStrokeAndDraft(
+  absPoints: Array<[number, number]>,
+  style: { size: 's'|'m'|'l'|'xl'; color: ColorName; opacity: number },
+  meta?: Record<string, any>
+) {
+  // 计算外接矩形与“局部坐标”点列（draft 使用局部点，AI 使用绝对点）
+  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity
+  for (const [x, y] of absPoints) { if (x < minX) minX = x; if (y < minY) minY = y; if (x > maxX) maxX = x; if (y > maxY) maxY = y }
+  const local = absPoints.map(([x, y]) => ({ x: x - minX, y: y - minY }))
+  const id = `pen_${Date.now().toString(36)}_${Math.random().toString(36).slice(2,6)}`
+
+  // AI 笔画（绝对坐标点，保持与协议一致：points:[[x,y,t?,pressure?], ...]）
+  const aiStroke: AIStrokeV11 = {
+    id,
+    tool: 'pen',
+    points: absPoints.map(([x, y]) => [x, y]),
+    style,
+    meta: { author: 'human', ...(meta ?? {}) }
+  }
+
+  // Draft（局部坐标，便于渲染/移动）
+  const draft: ShapeDraft = {
+    id,
+    kind: 'pen',
+    x: minX,
+    y: minY,
+    points: local,
+    style,
+    meta
+  }
+  return { aiStroke, draft }
+}
+
 // Candidate registry for preview sets
 type PreviewEntry = { payloadId: string; drafts: ShapeDraft[] }
 
 export default function LineArtKonvaBoard(){
   // Canvas size — you can attach resize observer later
   const [size] = useState({ width: window.innerWidth, height: window.innerHeight })
@@
   // Shape storage: accepted (official) shapes
   const [shapes, setShapes] = useState<ShapeDraft[]>([])
 
+  // -------- Drawing tool state（与 AI v1.1 同步样式/元信息）--------
+  // 当前“画笔配置”，在选择画笔时即与 AI 协议字段对齐（tool/style/meta）
+  const [brushSize, setBrushSize] = useState<'s'|'m'|'l'|'xl'>('m')
+  const [brushColor, setBrushColor] = useState<ColorName>('black')
+  const currentBrush = useMemo(() => ({
+    tool: 'pen' as const,
+    style: { size: brushSize, color: brushColor as ColorName, opacity: 1 },
+    meta: { author: 'human' } as Record<string, any>
+  }), [brushSize, brushColor])
+
+  // 是否正在绘制 + 原始鼠标轨迹（绝对坐标，形如 [x0,y0, x1,y1, ...]）
+  const [isDrawing, setIsDrawing] = useState(false)
+  const [rawPoints, setRawPoints] = useState<number[]>([])
+
+  // “人类绘制”的笔画栈（供未来擦除/撤销/重做等使用）：每项都保存 AI 协议笔画与 Draft
+  type DrawStackEntry = { ai: AIStrokeV11; draft: ShapeDraft }
+  const [drawStack, setDrawStack] = useState<DrawStackEntry[]>([])
+
   // Preview storage: map of payloadId -> drafts
   const [previews, setPreviews] = useState<Record<string, PreviewEntry>>({})
   const [currentPayloadId, setCurrentPayloadId] = useState<string|null>(null)
@@
   const fileRef = useRef<HTMLInputElement|null>(null)
@@
   const Grid: React.FC = () => {
@@
   }
 
+  // ---------- Pointer helpers ----------
+  const GRID_STEP = 32
+  const snapPoint = useCallback((x: number, y: number) => {
+    // 简单网格吸附：根据 snap 选项将坐标吸附到 GRID_STEP 的整数倍
+    return snap
+      ? [Math.round(x / GRID_STEP) * GRID_STEP, Math.round(y / GRID_STEP) * GRID_STEP]
+      : [x, y]
+  }, [snap])
+
+  // ---------- Stage 事件：自由笔绘制 ----------
+  const onMouseDown = useCallback((e: any) => {
+    const pos = e.target.getStage()?.getPointerPosition()
+    if (!pos) return
+    const [sx, sy] = snapPoint(pos.x, pos.y)
+    setIsDrawing(true)
+    setRawPoints([sx, sy]) // 以起点初始化
+  }, [snapPoint])
+
+  const onMouseMove = useCallback((e: any) => {
+    if (!isDrawing) return
+    const pos = e.target.getStage()?.getPointerPosition()
+    if (!pos) return
+    const [x, y] = snapPoint(pos.x, pos.y)
+    setRawPoints(prev => {
+      // 与上一点重复则忽略（减少冗余）
+      const n = prev.length
+      if (n >= 2 && prev[n-2] === x && prev[n-1] === y) return prev
+      return [...prev, x, y]
+    })
+  }, [isDrawing, snapPoint])
+
+  const onMouseUp = useCallback(() => {
+    if (!isDrawing) return
+    setIsDrawing(false)
+    if (rawPoints.length < 4) { setRawPoints([]); return }
+
+    // 1) 将 [x0,y0,x1,y1,...] 转为 [[x,y], ...] 点列
+    const absPts: Array<[number, number]> = []
+    for (let i = 0; i < rawPoints.length; i += 2) absPts.push([rawPoints[i], rawPoints[i+1]])
+
+    // 2) “贝塞尔曲线反拟合”思路：用 Chaikin 平滑替代 + 均匀步长采样，得到稳定点列
+    const smooth = chaikin(absPts, 2)
+    const sampled = resampleEvenly(smooth, 3) // 3px 间距可调
+
+    // 3) 将点列封装为 AI 协议笔画 + Draft，并压入“人类绘制栈”
+    const { aiStroke, draft } = buildAIStrokeAndDraft(sampled, currentBrush.style, currentBrush.meta)
+    setDrawStack(prev => [...prev, { ai: aiStroke, draft }])
+    setShapes(prev => [...prev, draft])  // 直接落地为正式形状
+
+    // 4) 清理临时轨迹
+    setRawPoints([])
+  }, [isDrawing, rawPoints, currentBrush])
+
   return (
     <div style={{ width: '100vw', height: '100vh', position: 'relative' }}>
       {/* Top bar (plain HTML) */}
       <div style={{ position:'absolute', left:'50%', transform:'translateX(-50%)', top:16, zIndex:1000, display:'flex', gap:8, alignItems:'center', background:'rgba(255,255,255,0.85)', backdropFilter:'blur(4px)', padding:'8px 12px', borderRadius:16, boxShadow:'0 4px 12px rgba(0,0,0,0.12)' }}>
         <button style={BTN} onClick={()=>setShowGrid(s=>!s)}>{showGrid?'Grid: ON':'Grid: OFF'}</button>
-        <button style={BTN} onClick={()=>setSnap(s=>!s)}>{snap?'Snap: ON':'Snap: OFF'}</button>
-        <select style={SEL} value={brushSize} onChange={(e)=>setBrushSize(e.target.value as any)}>
+        <button style={BTN} onClick={()=>setSnap(s=>!s)}>{snap?'Snap: ON':'Snap: OFF'}</button>
+        {/* 选择画笔粗细：这里的 brushSize 与 currentBrush.style.size 同步，满足 AI 协议 */}
+        <select style={SEL} value={brushSize} onChange={(e)=>setBrushSize(e.target.value as any)}>
           <option value="s">S</option><option value="m">M</option><option value="l">L</option><option value="xl">XL</option>
         </select>
-        <select style={SEL} value={brushColor} onChange={(e)=>setBrushColor(e.target.value as ColorName)}>
+        {/* 选择颜色：与 currentBrush.style.color 同步，满足 AI 协议 */}
+        <select style={SEL} value={brushColor} onChange={(e)=>setBrushColor(e.target.value as ColorName)}>
           {COLORS.map(c=> <option key={c} value={c}>{c}</option>)}
         </select>
         <button style={BTN} onClick={exportJSON}>Export JSON</button>
@@
       </div>
 
       {/* Konva canvas */}
-      <Stage width={size.width} height={size.height} style={{ background:'#fff' }}>
+      <Stage
+        width={size.width}
+        height={size.height}
+        style={{ background:'#fff' }}
+        // 绑定自由笔事件：mousedown/mousemove/mouseup
+        onMouseDown={onMouseDown}
+        onMouseMove={onMouseMove}
+        onMouseUp={onMouseUp}
+      >
         {/* Grid layer (non-interactive) */}
         <Layer listening={false}>{showGrid && <Grid />}</Layer>
 
         {/* Main shapes layer (accepted shapes) */}
         <Layer>
           {shapes.map(d => <DraftNode key={'s:'+d.id} d={d} />)}
+          {/* 正在绘制的临时笔迹（预览用，不入 shapes） */}
+          {isDrawing && rawPoints.length >= 4 && (
+            <KLine
+              points={rawPoints}
+              stroke={colorToStroke(brushColor)}
+              strokeWidth={SIZE_TO_WIDTH[brushSize]}
+              tension={0.4}
+              lineCap="round"
+              lineJoin="round"
+              opacity={0.8}
+            />
+          )}
         </Layer>
 
         {/* Preview layer(s): render each payloadId in a group */}
         <Layer>
           {Object.values(previews).map(entry => (
